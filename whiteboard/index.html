<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Infinite Whiteboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; height: 100%; width: 100%; overscroll-behavior: none; }
        canvas { display: block; touch-action: none; }
        .tool-btn.active { background-color: #2563eb; color: white; box-shadow: 0 10px 15px -3px rgba(37, 99, 235, 0.2); }
        .color-btn.active { transform: scale(1.25); border-color: #94a3b8; }
    </style>
</head>
<body class="bg-white select-none">

    <!-- Top Toolbar -->
    <div class="absolute top-4 left-1/2 -translate-x-1/2 z-10 flex items-center gap-1 sm:gap-2 bg-white/90 backdrop-blur p-2 rounded-2xl shadow-xl border border-slate-200 max-w-[95vw] overflow-x-auto">
        <button id="btn-pencil" class="tool-btn active p-2 sm:p-3 rounded-xl transition-all hover:bg-slate-100 text-slate-600" title="Pencil">
            <i data-lucide="pencil"></i>
        </button>
        <button id="btn-eraser" class="tool-btn p-2 sm:p-3 rounded-xl transition-all hover:bg-slate-100 text-slate-600" title="Eraser">
            <i data-lucide="eraser"></i>
        </button>
        <button id="btn-pan" class="tool-btn p-2 sm:p-3 rounded-xl transition-all hover:bg-slate-100 text-slate-600" title="Pan & Zoom">
            <i data-lucide="move"></i>
        </button>
        
        <div class="w-px h-8 bg-slate-200 mx-1"></div>
        
        <div id="color-palette" class="flex gap-1 px-1">
            <button data-color="#ef4444" class="color-btn w-6 h-6 rounded-full border-2 border-transparent bg-[#ef4444]" title="Red"></button>
            <button data-color="#f97316" class="color-btn w-6 h-6 rounded-full border-2 border-transparent bg-[#f97316]" title="Orange"></button>
            <button data-color="#eab308" class="color-btn w-6 h-6 rounded-full border-2 border-transparent bg-[#eab308]" title="Yellow"></button>
            <button data-color="#22c55e" class="color-btn w-6 h-6 rounded-full border-2 border-transparent bg-[#22c55e]" title="Green"></button>
            <button data-color="#3b82f6" class="color-btn active w-6 h-6 rounded-full border-2 border-transparent bg-[#3b82f6]" title="Blue"></button>
            <button data-color="#8b5cf6" class="color-btn w-6 h-6 rounded-full border-2 border-transparent bg-[#8b5cf6]" title="Violet"></button>
            <button data-color="#000000" class="color-btn w-6 h-6 rounded-full border-2 border-transparent bg-[#000000]" title="Black"></button>
            <button data-color="#6b7280" class="color-btn w-6 h-6 rounded-full border-2 border-transparent bg-[#6b7280]" title="Gray"></button>
        </div>
        
        <div class="w-px h-8 bg-slate-200 mx-1"></div>
        
        <div class="flex items-center gap-1 sm:gap-2 px-1">
            <button id="btn-width-down" class="p-1 hover:bg-slate-100 rounded text-slate-600"><i data-lucide="minus" size="14"></i></button>
            <span id="width-display" class="text-xs font-bold w-4 text-center text-slate-700">3</span>
            <button id="btn-width-up" class="p-1 hover:bg-slate-100 rounded text-slate-600"><i data-lucide="plus" size="14"></i></button>
        </div>
        
        <div class="w-px h-8 bg-slate-200 mx-1"></div>
        
        <button id="btn-clear" class="p-2 sm:p-3 rounded-xl text-red-500 hover:bg-red-50 transition-colors" title="Clear Board">
            <i data-lucide="trash-2"></i>
        </button>
    </div>

    <!-- Info Overlay -->
    <div class="absolute bottom-4 left-4 z-10 bg-white/80 backdrop-blur-sm p-3 rounded-lg border border-slate-200 text-[10px] text-slate-500 shadow-sm pointer-events-none">
        <p class="font-bold text-slate-700">Infinite Board</p>
        <p id="status-info">Initialising...</p>
        <p id="camera-info">Zoom: 100%</p>
    </div>

    <canvas id="whiteboardCanvas"></canvas>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, onSnapshot, addDoc, query, deleteDoc, getDocs, doc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Firebase Configuration ---
        let firebaseConfig;

        if (typeof __firebase_config !== 'undefined') {
            firebaseConfig = JSON.parse(__firebase_config);
        } else {
            // Restoring the specific API keys for the user's project
            firebaseConfig = {
                apiKey: "AIzaSyDDCSmDxGY0ltd3-KWsbbPKI_RvPQ2KIT0",
                authDomain: "whiteboard-23ad5.firebaseapp.com",
                projectId: "whiteboard-23ad5",
                storageBucket: "whiteboard-23ad5.firebasestorage.app",
                messagingSenderId: "1097713600229",
                appId: "1:1097713600229:web:b2beebee9d7a165a12360c",
                measurementId: "G-MR9C9WYE9M"
            };
        }

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-whiteboard';

        // --- App State ---
        let user = null;
        let strokes = [];
        let localStrokes = []; // Instantly preserves strokes even if Firebase connection/rules fail
        const imageCache = new Map(); // Cache image elements so we don't spam DOM creations
        let tool = 'pencil';
        let color = '#3b82f6';
        let lineWidth = 3;
        let camera = { x: 0, y: 0, zoom: 1 };
        let isDrawing = false;
        let currentPath = [];
        let lastTouch = null;

        const canvas = document.getElementById('whiteboardCanvas');
        const ctx = canvas.getContext('2d');
        const widthDisplay = document.getElementById('width-display');
        const statusInfo = document.getElementById('status-info');
        const cameraInfo = document.getElementById('camera-info');

        lucide.createIcons();

        function screenToWorld(screenX, screenY) {
            return {
                x: (screenX - camera.x) / camera.zoom,
                y: (screenY - camera.y) / camera.zoom
            };
        }

        function render() {
            const dpr = window.devicePixelRatio || 1;
            const w = window.innerWidth;
            const h = window.innerHeight;

            if (canvas.width !== w * dpr) {
                canvas.width = w * dpr;
                canvas.height = h * dpr;
                canvas.style.width = w + 'px';
                canvas.style.height = h + 'px';
                ctx.resetTransform();
                ctx.scale(dpr, dpr);
            }

            ctx.clearRect(0, 0, w, h);
            ctx.save();
            ctx.translate(camera.x, camera.y);
            ctx.scale(camera.zoom, camera.zoom);

            // Grid
            const gridSize = 50;
            ctx.beginPath();
            ctx.strokeStyle = '#f1f5f9';
            ctx.lineWidth = 1 / camera.zoom;
            const startX = Math.floor(-camera.x / camera.zoom / gridSize) * gridSize;
            const endX = startX + (w / camera.zoom) + gridSize;
            const startY = Math.floor(-camera.y / camera.zoom / gridSize) * gridSize;
            const endY = startY + (h / camera.zoom) + gridSize;

            for (let x = startX; x <= endX; x += gridSize) {
                ctx.moveTo(x, startY); ctx.lineTo(x, endY);
            }
            for (let y = startY; y <= endY; y += gridSize) {
                ctx.moveTo(startX, y); ctx.lineTo(endX, y);
            }
            ctx.stroke();

            const drawItem = (item) => {
                if (item.type === 'image') {
                    let img = imageCache.get(item.id);
                    if (!img) {
                        img = new Image();
                        img.src = item.data;
                        imageCache.set(item.id, img);
                    }
                    if (img.complete) {
                        ctx.drawImage(img, item.x, item.y, item.width, item.height);
                    }
                } else {
                    // Draw normal pen stroke path
                    if (!item.points || item.points.length < 2) return;
                    ctx.beginPath();
                    ctx.strokeStyle = item.color;
                    ctx.lineWidth = item.lineWidth;
                    ctx.lineJoin = 'round';
                    ctx.lineCap = 'round';
                    ctx.moveTo(item.points[0].x, item.points[0].y);
                    for (let i = 1; i < item.points.length; i++) {
                        ctx.lineTo(item.points[i].x, item.points[i].y);
                    }
                    ctx.stroke();
                }
            };

            // Remote strokes and images from Firebase
            strokes.forEach(s => drawItem(s));

            // Local fallback strokes/images (ensures they never vanish)
            localStrokes.forEach(s => drawItem(s));

            // Local active stroke
            if (isDrawing && tool === 'pencil') {
                drawItem({ points: currentPath, color, lineWidth });
            }

            // Eraser cursor
            if (isDrawing && tool === 'eraser') {
                const lastPos = currentPath[currentPath.length - 1];
                if (lastPos) {
                    ctx.beginPath();
                    ctx.arc(lastPos.x, lastPos.y, 15 / camera.zoom, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            ctx.restore();
            cameraInfo.innerText = `Zoom: ${(camera.zoom * 100).toFixed(0)}%`;
            requestAnimationFrame(render);
        }

        async function eraseAt(worldPos) {
            const radius = 20 / camera.zoom;

            const isHit = (item) => {
                if (item.type === 'image') {
                    // Check if eraser overlaps the bounding box of the image
                    return worldPos.x >= item.x && worldPos.x <= item.x + item.width &&
                           worldPos.y >= item.y && worldPos.y <= item.y + item.height;
                } else {
                    return item.points && item.points.some(p => Math.hypot(p.x - worldPos.x, p.y - worldPos.y) < radius);
                }
            };

            // Instantly remove from local fallback array
            localStrokes = localStrokes.filter(stroke => !isHit(stroke));

            if (!user) return;
            
            // Remove from Firebase synced array
            const strokesToErase = strokes.filter(stroke => isHit(stroke));

            for (const stroke of strokesToErase) {
                // Fire and forget delete to keep UI fast
                deleteDoc(doc(db, 'artifacts', appId, 'public', 'data', 'strokes', stroke.id))
                    .catch(e => console.error("Erase error:", e));
            }
        }

        const handleStart = (clientX, clientY) => {
            isDrawing = true;
            const worldPos = screenToWorld(clientX, clientY);
            if (tool === 'pencil' || tool === 'eraser') {
                currentPath = [worldPos];
                if (tool === 'eraser') eraseAt(worldPos);
            }
            lastTouch = { x: clientX, y: clientY };
        };

        const handleMove = (clientX, clientY, movementX, movementY) => {
            if (!isDrawing) return;
            if (tool === 'pan') {
                camera.x += movementX;
                camera.y += movementY;
            } else {
                const worldPos = screenToWorld(clientX, clientY);
                currentPath.push(worldPos);
                if (tool === 'eraser') eraseAt(worldPos);
            }
        };

        const handleEnd = async () => {
            if (!isDrawing) return;
            isDrawing = false;
            
            if (tool === 'pencil' && currentPath.length > 1) {
                const strokePath = [...currentPath]; // copy current points
                
                // Add to local strokes instantly to completely prevent disappearing issues
                localStrokes.push({ 
                    id: 'local-' + Date.now(), 
                    points: strokePath, 
                    color, 
                    lineWidth, 
                    userId: user ? user.uid : 'offline' 
                });
                
                if (user) {
                    const strokeData = { 
                        points: JSON.stringify(strokePath), 
                        color, 
                        lineWidth, 
                        userId: user.uid, 
                        createdAt: Date.now() 
                    };
                    
                    // Attempt to save to Firebase, catching errors so it doesn't break
                    addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'strokes'), strokeData)
                        .catch(e => {
                            console.warn("Firebase save rejected/failed. Stroke kept locally.", e);
                        });
                }
            }
            currentPath = [];
            lastTouch = null;
        };

        // --- Handle Image Paste Events ---
        window.addEventListener('paste', (e) => {
            const items = (e.clipboardData || e.originalEvent.clipboardData).items;
            for (let index in items) {
                const item = items[index];
                if (item.kind === 'file' && item.type.startsWith('image/')) {
                    const blob = item.getAsFile();
                    const reader = new FileReader();
                    
                    reader.onload = (event) => {
                        const img = new Image();
                        img.onload = () => {
                            // Target center of screen for placement
                            const centerPos = screenToWorld(window.innerWidth / 2, window.innerHeight / 2);
                            
                            // Constrain massive images so they don't break firestore doc limits
                            let w = img.width;
                            let h = img.height;
                            const maxDim = 800; 
                            if (w > maxDim || h > maxDim) {
                                const ratio = Math.min(maxDim / w, maxDim / h);
                                w *= ratio;
                                h *= ratio;
                            }
                            
                            // Draw to offscreen canvas to compress as WebP
                            const tempCanvas = document.createElement('canvas');
                            tempCanvas.width = w;
                            tempCanvas.height = h;
                            const tCtx = tempCanvas.getContext('2d');
                            tCtx.drawImage(img, 0, 0, w, h);
                            
                            // 60% quality WebP to ensure it's lightweight for Firebase
                            const compressedData = tempCanvas.toDataURL('image/webp', 0.6);

                            const imgData = {
                                type: 'image',
                                data: compressedData,
                                x: centerPos.x - w / 2,
                                y: centerPos.y - h / 2,
                                width: w,
                                height: h,
                                userId: user ? user.uid : 'offline',
                                createdAt: Date.now()
                            };

                            const localId = 'local-img-' + Date.now();
                            localStrokes.push({ id: localId, ...imgData });

                            if (user) {
                                addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'strokes'), imgData)
                                    .catch(err => console.warn("Firebase save rejected. Image kept locally.", err));
                            }
                        };
                        img.src = event.target.result;
                    };
                    reader.readAsDataURL(blob);
                }
            }
        });

        // Mouse Events
        canvas.addEventListener('mousedown', (e) => handleStart(e.clientX, e.clientY));
        window.addEventListener('mousemove', (e) => handleMove(e.clientX, e.clientY, e.movementX, e.movementY));
        window.addEventListener('mouseup', handleEnd);

        // Touch Events
        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                handleStart(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (e.touches.length === 1 && lastTouch) {
                const touch = e.touches[0];
                handleMove(touch.clientX, touch.clientY, touch.clientX - lastTouch.x, touch.clientY - lastTouch.y);
                lastTouch = { x: touch.clientX, y: touch.clientY };
            }
        }, { passive: false });

        canvas.addEventListener('touchend', handleEnd);

        // Zoom
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const factor = Math.pow(1.1, -e.deltaY / 150);
            const newZoom = Math.min(Math.max(camera.zoom * factor, 0.05), 20);
            const mouseBefore = screenToWorld(e.clientX, e.clientY);
            camera.zoom = newZoom;
            camera.x = e.clientX - mouseBefore.x * newZoom;
            camera.y = e.clientY - mouseBefore.y * newZoom;
        }, { passive: false });

        // UI Interactions
        const toolBtns = document.querySelectorAll('.tool-btn');
        const setActiveTool = (id, toolName) => {
            toolBtns.forEach(b => b.classList.remove('active'));
            document.getElementById(id).classList.add('active');
            tool = toolName;
            canvas.style.cursor = tool === 'pan' ? 'grab' : tool === 'eraser' ? 'cell' : 'crosshair';
        };

        document.getElementById('btn-pencil').onclick = () => setActiveTool('btn-pencil', 'pencil');
        document.getElementById('btn-eraser').onclick = () => setActiveTool('btn-eraser', 'eraser');
        document.getElementById('btn-pan').onclick = () => setActiveTool('btn-pan', 'pan');

        document.querySelectorAll('.color-btn').forEach(btn => {
            btn.onclick = () => {
                document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                color = btn.dataset.color;
                setActiveTool('btn-pencil', 'pencil');
            };
        });

        document.getElementById('btn-width-up').onclick = () => { lineWidth = Math.min(20, lineWidth + 1); widthDisplay.innerText = lineWidth; };
        document.getElementById('btn-width-down').onclick = () => { lineWidth = Math.max(1, lineWidth - 1); widthDisplay.innerText = lineWidth; };

        document.getElementById('btn-clear').onclick = async () => {
            localStrokes = []; // Instantly clear locally
            
            if (!user) return;
            try {
                const snap = await getDocs(collection(db, 'artifacts', appId, 'public', 'data', 'strokes'));
                const deletePromises = snap.docs.map(d => deleteDoc(doc(db, 'artifacts', appId, 'public', 'data', 'strokes', d.id)));
                await Promise.all(deletePromises);
            } catch (e) { console.error("Clear error:", e); }
        };

        // Start rendering unconditionally
        requestAnimationFrame(render);

        // Initialize App
        async function init() {
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (e) {
                statusInfo.innerText = "Offline Mode (Local Only)";
                console.error("Auth failed (Is Anonymous Sign-in enabled in your Firebase project?):", e);
                // Intentionally NOT returning here so offline functionality works
            }

            onAuthStateChanged(auth, (u) => {
                user = u;
                if (u) {
                    statusInfo.innerText = `Online (${u.uid.substring(0,5)}...)`;
                    
                    const q = collection(db, 'artifacts', appId, 'public', 'data', 'strokes');
                    onSnapshot(q, (snap) => {
                        strokes = snap.docs.map(d => {
                            const data = d.data();
                            if (data.type === 'image') {
                                return { id: d.id, ...data };
                            }
                            
                            // Handle standard strokes
                            let points = [];
                            try {
                                points = typeof data.points === 'string' ? JSON.parse(data.points) : data.points;
                            } catch(e) { points = []; }
                            return { id: d.id, ...data, points };
                        });
                    }, (err) => {
                        console.error("Firestore sync error (Check Firestore Rules!):", err);
                        statusInfo.innerText = "Sync Error - Running Locally";
                    });
                } else {
                    statusInfo.innerText = "Offline Mode";
                }
            });
        }

        init();
    </script>
</body>
</html>
