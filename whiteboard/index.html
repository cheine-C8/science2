<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Infinite Whiteboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; height: 100%; width: 100%; overscroll-behavior: none; }
        canvas { display: block; touch-action: none; }
        .tool-btn.active { background-color: #2563eb; color: white; box-shadow: 0 10px 15px -3px rgba(37, 99, 235, 0.2); }
        .color-btn.active { transform: scale(1.25); border-color: #94a3b8; }
    </style>
</head>
<body class="bg-white select-none">

    <!-- Top Toolbar -->
    <div class="absolute top-4 left-1/2 -translate-x-1/2 z-10 flex items-center gap-1 sm:gap-2 bg-white/90 backdrop-blur p-2 rounded-2xl shadow-xl border border-slate-200 max-w-[95vw] overflow-x-auto">
        <button id="btn-pencil" class="tool-btn active p-2 sm:p-3 rounded-xl transition-all hover:bg-slate-100 text-slate-600" title="Pencil">
            <i data-lucide="pencil"></i>
        </button>
        <button id="btn-eraser" class="tool-btn p-2 sm:p-3 rounded-xl transition-all hover:bg-slate-100 text-slate-600" title="Eraser">
            <i data-lucide="eraser"></i>
        </button>
        <button id="btn-pan" class="tool-btn p-2 sm:p-3 rounded-xl transition-all hover:bg-slate-100 text-slate-600" title="Pan & Zoom">
            <i data-lucide="move"></i>
        </button>
        
        <div class="w-px h-8 bg-slate-200 mx-1"></div>
        
        <div id="color-palette" class="flex gap-1 px-1">
            <button data-color="#3b82f6" class="color-btn active w-6 h-6 rounded-full border-2 border-transparent bg-[#3b82f6]"></button>
            <button data-color="#ef4444" class="color-btn w-6 h-6 rounded-full border-2 border-transparent bg-[#ef4444]"></button>
            <button data-color="#10b981" class="color-btn w-6 h-6 rounded-full border-2 border-transparent bg-[#10b981]"></button>
            <button data-color="#000000" class="color-btn w-6 h-6 rounded-full border-2 border-transparent bg-[#000000]"></button>
        </div>
        
        <div class="w-px h-8 bg-slate-200 mx-1"></div>
        
        <div class="flex items-center gap-1 sm:gap-2 px-1">
            <button id="btn-width-down" class="p-1 hover:bg-slate-100 rounded text-slate-600"><i data-lucide="minus" size="14"></i></button>
            <span id="width-display" class="text-xs font-bold w-4 text-center text-slate-700">3</span>
            <button id="btn-width-up" class="p-1 hover:bg-slate-100 rounded text-slate-600"><i data-lucide="plus" size="14"></i></button>
        </div>
        
        <div class="w-px h-8 bg-slate-200 mx-1"></div>
        
        <button id="btn-clear" class="p-2 sm:p-3 rounded-xl text-red-500 hover:bg-red-50 transition-colors" title="Clear Board">
            <i data-lucide="trash-2"></i>
        </button>
    </div>

    <!-- Info Overlay -->
    <div class="absolute bottom-4 left-4 z-10 bg-white/80 backdrop-blur-sm p-3 rounded-lg border border-slate-200 text-[10px] text-slate-500 shadow-sm pointer-events-none">
        <p class="font-bold text-slate-700">Infinite Board</p>
        <p id="status-info">Initialising...</p>
        <p id="camera-info">Zoom: 100%</p>
    </div>

    <canvas id="whiteboardCanvas"></canvas>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, onSnapshot, addDoc, query, deleteDoc, getDocs, doc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Firebase Configuration ---
        let firebaseConfig;

        if (typeof __firebase_config !== 'undefined') {
            firebaseConfig = JSON.parse(__firebase_config);
        } else {
            // Restoring the specific API keys for the user's project
            firebaseConfig = {
                apiKey: "AIzaSyDDCSmDxGY0ltd3-KWsbbPKI_RvPQ2KIT0",
                authDomain: "whiteboard-23ad5.firebaseapp.com",
                projectId: "whiteboard-23ad5",
                storageBucket: "whiteboard-23ad5.firebasestorage.app",
                messagingSenderId: "1097713600229",
                appId: "1:1097713600229:web:b2beebee9d7a165a12360c",
                measurementId: "G-MR9C9WYE9M"
            };
        }

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-whiteboard';

        // --- App State ---
        let user = null;
        let strokes = [];
        let tool = 'pencil';
        let color = '#3b82f6';
        let lineWidth = 3;
        let camera = { x: 0, y: 0, zoom: 1 };
        let isDrawing = false;
        let currentPath = [];
        let lastTouch = null;

        const canvas = document.getElementById('whiteboardCanvas');
        const ctx = canvas.getContext('2d');
        const widthDisplay = document.getElementById('width-display');
        const statusInfo = document.getElementById('status-info');
        const cameraInfo = document.getElementById('camera-info');

        lucide.createIcons();

        function screenToWorld(screenX, screenY) {
            return {
                x: (screenX - camera.x) / camera.zoom,
                y: (screenY - camera.y) / camera.zoom
            };
        }

        function render() {
            const dpr = window.devicePixelRatio || 1;
            const w = window.innerWidth;
            const h = window.innerHeight;

            if (canvas.width !== w * dpr) {
                canvas.width = w * dpr;
                canvas.height = h * dpr;
                canvas.style.width = w + 'px';
                canvas.style.height = h + 'px';
                ctx.resetTransform();
                ctx.scale(dpr, dpr);
            }

            ctx.clearRect(0, 0, w, h);
            ctx.save();
            ctx.translate(camera.x, camera.y);
            ctx.scale(camera.zoom, camera.zoom);

            // Grid
            const gridSize = 50;
            ctx.beginPath();
            ctx.strokeStyle = '#f1f5f9';
            ctx.lineWidth = 1 / camera.zoom;
            const startX = Math.floor(-camera.x / camera.zoom / gridSize) * gridSize;
            const endX = startX + (w / camera.zoom) + gridSize;
            const startY = Math.floor(-camera.y / camera.zoom / gridSize) * gridSize;
            const endY = startY + (h / camera.zoom) + gridSize;

            for (let x = startX; x <= endX; x += gridSize) {
                ctx.moveTo(x, startY); ctx.lineTo(x, endY);
            }
            for (let y = startY; y <= endY; y += gridSize) {
                ctx.moveTo(startX, y); ctx.lineTo(endX, y);
            }
            ctx.stroke();

            const drawPath = (path, sColor, sWidth) => {
                if (!path || path.length < 2) return;
                ctx.beginPath();
                ctx.strokeStyle = sColor;
                ctx.lineWidth = sWidth;
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
                ctx.moveTo(path[0].x, path[0].y);
                for (let i = 1; i < path.length; i++) {
                    ctx.lineTo(path[i].x, path[i].y);
                }
                ctx.stroke();
            };

            // Remote strokes
            strokes.forEach(s => drawPath(s.points, s.color, s.lineWidth));

            // Local active stroke
            if (isDrawing && tool === 'pencil') {
                drawPath(currentPath, color, lineWidth);
            }

            // Eraser cursor
            if (isDrawing && tool === 'eraser') {
                const lastPos = currentPath[currentPath.length - 1];
                if (lastPos) {
                    ctx.beginPath();
                    ctx.arc(lastPos.x, lastPos.y, 15 / camera.zoom, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            ctx.restore();
            cameraInfo.innerText = `Zoom: ${(camera.zoom * 100).toFixed(0)}%`;
            requestAnimationFrame(render);
        }

        async function eraseAt(worldPos) {
            if (!user) return;
            const radius = 20 / camera.zoom;
            const strokesToErase = strokes.filter(stroke => 
                stroke.points && stroke.points.some(p => Math.hypot(p.x - worldPos.x, p.y - worldPos.y) < radius)
            );

            for (const stroke of strokesToErase) {
                try {
                    await deleteDoc(doc(db, 'artifacts', appId, 'public', 'data', 'strokes', stroke.id));
                } catch (e) { console.error("Erase error:", e); }
            }
        }

        const handleStart = (clientX, clientY) => {
            isDrawing = true;
            const worldPos = screenToWorld(clientX, clientY);
            if (tool === 'pencil' || tool === 'eraser') {
                currentPath = [worldPos];
                if (tool === 'eraser') eraseAt(worldPos);
            }
            lastTouch = { x: clientX, y: clientY };
        };

        const handleMove = (clientX, clientY, movementX, movementY) => {
            if (!isDrawing) return;
            if (tool === 'pan') {
                camera.x += movementX;
                camera.y += movementY;
            } else {
                const worldPos = screenToWorld(clientX, clientY);
                currentPath.push(worldPos);
                if (tool === 'eraser') eraseAt(worldPos);
            }
        };

        const handleEnd = async () => {
            if (!isDrawing) return;
            isDrawing = false;
            
            if (tool === 'pencil' && currentPath.length > 1 && user) {
                const strokeData = { 
                    points: JSON.stringify(currentPath), 
                    color, 
                    lineWidth, 
                    userId: user.uid, 
                    createdAt: Date.now() 
                };
                
                try {
                    await addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'strokes'), strokeData);
                } catch (e) { 
                    console.error("Save error:", e); 
                }
            }
            currentPath = [];
            lastTouch = null;
        };

        // Mouse Events
        canvas.addEventListener('mousedown', (e) => handleStart(e.clientX, e.clientY));
        window.addEventListener('mousemove', (e) => handleMove(e.clientX, e.clientY, e.movementX, e.movementY));
        window.addEventListener('mouseup', handleEnd);

        // Touch Events
        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                handleStart(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (e.touches.length === 1 && lastTouch) {
                const touch = e.touches[0];
                handleMove(touch.clientX, touch.clientY, touch.clientX - lastTouch.x, touch.clientY - lastTouch.y);
                lastTouch = { x: touch.clientX, y: touch.clientY };
            }
        }, { passive: false });

        canvas.addEventListener('touchend', handleEnd);

        // Zoom
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const factor = Math.pow(1.1, -e.deltaY / 150);
            const newZoom = Math.min(Math.max(camera.zoom * factor, 0.05), 20);
            const mouseBefore = screenToWorld(e.clientX, e.clientY);
            camera.zoom = newZoom;
            camera.x = e.clientX - mouseBefore.x * newZoom;
            camera.y = e.clientY - mouseBefore.y * newZoom;
        }, { passive: false });

        // UI Interactions
        const toolBtns = document.querySelectorAll('.tool-btn');
        const setActiveTool = (id, toolName) => {
            toolBtns.forEach(b => b.classList.remove('active'));
            document.getElementById(id).classList.add('active');
            tool = toolName;
            canvas.style.cursor = tool === 'pan' ? 'grab' : tool === 'eraser' ? 'cell' : 'crosshair';
        };

        document.getElementById('btn-pencil').onclick = () => setActiveTool('btn-pencil', 'pencil');
        document.getElementById('btn-eraser').onclick = () => setActiveTool('btn-eraser', 'eraser');
        document.getElementById('btn-pan').onclick = () => setActiveTool('btn-pan', 'pan');

        document.querySelectorAll('.color-btn').forEach(btn => {
            btn.onclick = () => {
                document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                color = btn.dataset.color;
                setActiveTool('btn-pencil', 'pencil');
            };
        });

        document.getElementById('btn-width-up').onclick = () => { lineWidth = Math.min(20, lineWidth + 1); widthDisplay.innerText = lineWidth; };
        document.getElementById('btn-width-down').onclick = () => { lineWidth = Math.max(1, lineWidth - 1); widthDisplay.innerText = lineWidth; };

        document.getElementById('btn-clear').onclick = async () => {
            if (!user || !confirm("Clear the entire board for everyone?")) return;
            try {
                const snap = await getDocs(collection(db, 'artifacts', appId, 'public', 'data', 'strokes'));
                const deletePromises = snap.docs.map(d => deleteDoc(doc(db, 'artifacts', appId, 'public', 'data', 'strokes', d.id)));
                await Promise.all(deletePromises);
            } catch (e) { console.error("Clear error:", e); }
        };

        // Initialize App
        async function init() {
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (e) {
                statusInfo.innerText = "Auth Failed";
                console.error(e);
                return;
            }

            onAuthStateChanged(auth, (u) => {
                user = u;
                if (u) {
                    statusInfo.innerText = `User: ${u.uid}`;
                    
                    const q = collection(db, 'artifacts', appId, 'public', 'data', 'strokes');
                    onSnapshot(q, (snap) => {
                        strokes = snap.docs.map(d => {
                            const data = d.data();
                            let points = [];
                            try {
                                points = typeof data.points === 'string' ? JSON.parse(data.points) : data.points;
                            } catch(e) { points = []; }
                            return { id: d.id, ...data, points };
                        });
                    }, (err) => {
                        console.error("Firestore error:", err);
                        statusInfo.innerText = "Sync Error";
                    });
                }
            });

            requestAnimationFrame(render);
        }

        init();
    </script>
</body>
</html>
