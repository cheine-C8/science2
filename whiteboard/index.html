<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Whiteboard</title>
    <!-- React and Babel for running JSX in the browser -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        /**
         * STEP 2 & 3: SETUP FIREBASE SDK
         * 1. Go to Firebase Console > Project Settings.
         * 2. Scroll down to "Your apps" and copy the firebaseConfig object.
         * 3. Paste it below, replacing the placeholder values.
         */
        const firebaseConfig = {
            apiKey: "AIzaSyDDCSmDxGY0ltd3-KWsbbPKI_RvPQ2KIT0",
            authDomain: "whiteboard-23ad5.firebaseapp.com",
            projectId: "whiteboard-23ad5",
            storageBucket: "whiteboard-23ad5.firebasestorage.app",
            messagingSenderId: "1097713600229",
            appId: "1:1097713600229:web:b2beebee9d7a165a12360c",
            measurementId: "G-MR9C9WYE9M"
        };

        // These imports load the Firebase SDK directly from Google's servers (CDN)
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
        import { getFirestore, collection, onSnapshot, addDoc, query, deleteDoc, getDocs, doc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        // Initialize Firebase services
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        const { useState, useEffect, useRef, useCallback } = React;

        const App = () => {
            const [user, setUser] = useState(null);
            const [strokes, setStrokes] = useState([]);
            const [tool, setTool] = useState('pencil');
            const [color, setColor] = useState('#3b82f6');
            const [lineWidth, setLineWidth] = useState(3);
            const [camera, setCamera] = useState({ x: 0, y: 0, zoom: 1 });
            
            const canvasRef = useRef(null);
            const isDrawing = useRef(false);
            const currentPathRef = useRef([]);

            // Handle Anonymous Authentication
            useEffect(() => {
                signInAnonymously(auth).catch((err) => {
                    console.error("Auth failed. Ensure Anonymous Auth is enabled in Firebase Console and your domain is whitelisted.", err);
                });
                return onAuthStateChanged(auth, setUser);
            }, []);

            // Real-time synchronization with Firestore
            useEffect(() => {
                if (!user) return;
                // We store all lines in a collection called "strokes"
                const q = query(collection(db, "strokes"));
                const unsubscribe = onSnapshot(q, (snapshot) => {
                    setStrokes(snapshot.docs.map(d => ({ id: d.id, ...d.data() })));
                }, (error) => {
                    console.error("Firestore error. Check your security rules.", error);
                });
                return () => unsubscribe();
            }, [user]);

            const screenToWorld = (sx, sy) => ({
                x: (sx - camera.x) / camera.zoom,
                y: (sy - camera.y) / camera.zoom
            });

            const render = useCallback(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                
                // Set canvas size to full screen
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                
                ctx.save();
                ctx.translate(camera.x, camera.y);
                ctx.scale(camera.zoom, camera.zoom);

                // Draw Infinite Grid
                ctx.beginPath();
                ctx.strokeStyle = '#f1f5f9';
                ctx.lineWidth = 1 / camera.zoom;
                const step = 50;
                const viewLeft = -camera.x / camera.zoom;
                const viewTop = -camera.y / camera.zoom;
                const viewRight = viewLeft + window.innerWidth / camera.zoom;
                const viewBottom = viewTop + window.innerHeight / camera.zoom;

                for (let x = Math.floor(viewLeft / step) * step; x <= viewRight; x += step) {
                    ctx.moveTo(x, viewTop); ctx.lineTo(x, viewBottom);
                }
                for (let y = Math.floor(viewTop / step) * step; y <= viewBottom; y += step) {
                    ctx.moveTo(viewLeft, y); ctx.lineTo(viewRight, y);
                }
                ctx.stroke();

                const drawLine = (path, c, w) => {
                    if (!path?.length) return;
                    ctx.beginPath();
                    ctx.strokeStyle = c;
                    ctx.lineWidth = w;
                    ctx.lineJoin = 'round'; ctx.lineCap = 'round';
                    ctx.moveTo(path[0].x, path[0].y);
                    path.forEach(p => ctx.lineTo(p.x, p.y));
                    ctx.stroke();
                };

                // Render saved strokes from cloud
                strokes.forEach(s => drawLine(s.points, s.color, s.lineWidth));
                
                // Render local active drawing (zero latency)
                if (isDrawing.current && tool === 'pencil') {
                    drawLine(currentPathRef.current, color, lineWidth);
                }

                ctx.restore();
            }, [strokes, camera, color, lineWidth, tool]);

            // Animation Loop
            useEffect(() => {
                let id;
                const loop = () => { render(); id = requestAnimationFrame(loop); };
                id = requestAnimationFrame(loop);
                return () => cancelAnimationFrame(id);
            }, [render]);

            const eraseAt = async (pos) => {
                const radius = 20 / camera.zoom;
                // Loop through strokes and delete if point is near eraser
                for (const s of strokes) {
                    if (s.points.some(p => Math.hypot(p.x - pos.x, p.y - pos.y) < radius)) {
                        await deleteDoc(doc(db, "strokes", s.id));
                    }
                }
            };

            const onMove = (e) => {
                if (!isDrawing.current) return;
                if (tool === 'pan') {
                    setCamera(prev => ({ ...prev, x: prev.x + e.movementX, y: prev.y + e.movementY }));
                } else {
                    const p = screenToWorld(e.clientX, e.clientY);
                    currentPathRef.current.push(p);
                    if (tool === 'eraser') eraseAt(p);
                }
            };

            const onEnd = async () => {
                if (isDrawing.current && tool === 'pencil' && currentPathRef.current.length > 1) {
                    const path = [...currentPathRef.current];
                    currentPathRef.current = [];
                    // Save the completed line to Firestore
                    await addDoc(collection(db, "strokes"), { 
                        points: path, 
                        color, 
                        lineWidth, 
                        timestamp: Date.now() 
                    });
                }
                isDrawing.current = false;
            };

            return (
                <div className="fixed inset-0 bg-white overflow-hidden font-sans">
                    {/* Toolbar */}
                    <div className="absolute top-4 left-1/2 -translate-x-1/2 z-10 flex items-center gap-3 bg-white p-3 rounded-2xl shadow-2xl border border-slate-200">
                        <button 
                            onClick={() => setTool('pencil')} 
                            className={`p-2 rounded-lg transition ${tool === 'pencil' ? 'bg-blue-600 text-white' : 'hover:bg-slate-100 text-slate-600'}`}
                        >
                            ‚úèÔ∏è
                        </button>
                        <button 
                            onClick={() => setTool('eraser')} 
                            className={`p-2 rounded-lg transition ${tool === 'eraser' ? 'bg-blue-600 text-white' : 'hover:bg-slate-100 text-slate-600'}`}
                        >
                            üßΩ
                        </button>
                        <button 
                            onClick={() => setTool('pan')} 
                            className={`p-2 rounded-lg transition ${tool === 'pan' ? 'bg-blue-600 text-white' : 'hover:bg-slate-100 text-slate-600'}`}
                        >
                            ‚úã
                        </button>
                        <div className="w-px h-6 bg-slate-200 mx-1" />
                        <input 
                            type="color" 
                            value={color} 
                            onChange={e => setColor(e.target.value)} 
                            className="w-8 h-8 rounded cursor-pointer border-none" 
                        />
                    </div>

                    <canvas 
                        ref={canvasRef} 
                        onMouseDown={(e) => { 
                            isDrawing.current = true; 
                            if(tool !== 'pan') currentPathRef.current = [screenToWorld(e.clientX, e.clientY)]; 
                        }}
                        onMouseMove={onMove} 
                        onMouseUp={onEnd}
                        onWheel={(e) => {
                            const factor = Math.pow(1.1, -e.deltaY / 150);
                            setCamera(prev => ({ ...prev, zoom: Math.min(Math.max(prev.zoom * factor, 0.1), 10) }));
                        }}
                        className={`w-full h-full touch-none ${tool === 'pan' ? 'cursor-grab' : 'cursor-crosshair'}`}
                    />
                    
                    {/* User Info Overlay */}
                    <div className="absolute bottom-4 left-4 bg-white/80 backdrop-blur p-2 rounded border text-[10px] text-slate-500 pointer-events-none">
                        Zoom: {(camera.zoom * 100).toFixed(0)}% | User: {user ? 'Connected' : 'Connecting...'}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
